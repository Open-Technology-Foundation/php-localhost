#!/bin/bash
set -eEuo pipefail
shopt -s extglob
readonly -- PRG=$(basename -- "$(readlink -en -- "$0")")
readonly -- BUILD=422
readonly -- VERSION=1.0."$BUILD"
declare -i PORT=8000       # Default port to use for PHP server
declare -- DIRECTORY=''    # Default directory to serve (will fallback to .)
declare -- MODE=fg         # Default mode: fg (foreground), bg (background), screen
declare -i VERBOSE=1       # Verbose output by default
declare -a SERVER_PIDS=()  # Array to track PHP server processes for cleanup

# Utility functions
vecho() { ((VERBOSE)) && echo "$PRG": "$*" || true; }  # Verbose echo (respects quiet mode)
error() { >&2        echo "$PRG": error: "$*"; }  # Error message to stderr
die() { error "${2:-}"; exit "${1:-1}"; }  # Print error and exit with code

# Error trap and cleanup function
cleanup() {
  local -i exit_code=$?
  local -- pid
  # Only clean up if we're in foreground mode or trap was triggered due to error
  if [[ "$MODE" == "fg" || $exit_code -ne 0 ]]; then
    for pid in "${SERVER_PIDS[@]}"; do
      if kill -0 "$pid" 2>/dev/null; then
        vecho "Stopping PHP server (PID: $pid)"
        kill "$pid" 2>/dev/null || true
      fi
    done
  fi
  exit $exit_code
}
# Set up traps for clean exit
trap cleanup EXIT INT TERM

# Check for required dependencies
check_dependencies() {
  local -a missing=()
  # Check for PHP
  command -v php >/dev/null 2>&1 || missing+=("php")
  # Check for lsof (for process detection)
  command -v lsof >/dev/null 2>&1 || missing+=("lsof")
  # Check for nc (for port checking)
  command -v nc >/dev/null 2>&1 || missing+=("netcat")
  # If we're using screen mode, check for screen
  [[ "$MODE" == screen ]] && { command -v screen >/dev/null 2>&1 || missing+=("screen"); }
  # If we have missing dependencies, report and exit
  if ((${#missing[@]})); then
    error "Missing required dependencies: ${missing[*]}"
    error "Please install the missing packages and try again."
    exit 1
  fi
  # Validate PHP version
  local php_version
  php_version=$(php -r 'echo PHP_VERSION;')
  if [[ -z "$php_version" ]]; then
    error "Could not determine PHP version"
    exit 1
  fi
  vecho "Using PHP version $php_version"
  return 0
}

usage() {
  cat <<EOT
$PRG $VERSION - Create a webdev php localhost

Usage: $PRG [-q|--quiet] [-v|--verbose] [-V|--version] [-h|--help] [port] [dir] [mode]

Arguments can be in any order.

Parameters:
  port    - Port number to use (default: $PORT)
  dir     - Directory to serve (default: ${DIRECTORY:-.})
  mode    - Server run mode (default: $MODE)
              fg     - Run in foreground
              bg     - Run in background
              screen - Run in screen session

Options:
  -q, --quiet   Suppress output and auto-kill existing servers on the same port
  -v, --verbose Show verbose output (default)
  -V, --version Display version information
  -h, --help    Display this help message

Features:
  - Automatically detects and offers to kill existing PHP servers on the same port
  - Supports running in foreground, background, or screen session
  - Automatically uses router.php if present in the served directory
  - Validates port numbers and ensures they are integers
  - Verifies directory existence and resolves to absolute path
  - Checks for required dependencies (php, lsof, nc, screen)
  - Provides clean shutdown via signal trapping

Router Support:
  If a file named 'router.php' exists in the served directory, it will be used
  automatically to handle URL routing and custom request processing.
  
  A router file allows you to:
  - Handle URLs that don't match physical files
  - Create custom API endpoints
  - Define rewrite rules and redirects
  - Implement custom 404 handlers

Examples:
  $PRG                     # Default: port=$PORT, dir=${DIRECTORY:-.}, mode=$MODE
  $PRG 8001 html bg        # Run on port 8001 serving html in background
  $PRG . 8080              # Serve current directory on port 8080
  $PRG screen 8087 public  # Run in screen session on port 8087 serving public
  $PRG html screen 8000    # Serve html on port 8000 in screen session
  $PRG -q 8080 .           # Quiet mode, auto-kill existing servers on port 8080
EOT
  exit "${1:-1}"
}

# Validate port number
validate_port() {
  local -i p="$1"
  # Check if port is a valid number
  [[ "$p" =~ ^[0-9]+$ ]] || die 22 "Invalid port number: $1 (must be a number)"
  # Check port range
  if ((p < 1024 || p > 65535)); then
    vecho "warning: Port $p is outside the recommended range (1024-65535)"
    ((p < 1024)) && vecho "Ports below 1024 typically require root privileges"
  fi
  return 0
}

# Process command line arguments
# shellcheck disable=SC2206
while (($#)); do case $1 in
  -p|--port)      shift
                  validate_port "${1:-"$PORT"}"; PORT=${1:-"$PORT"} ;;
  +([0-9]))       validate_port "$1"; PORT=$1 ;;
  --bg|--fg|--screen)
                  MODE=${1:2} ;;
  -d|--directory) [[ -n $DIRECTORY ]] && die 1 "Directory '$DIRECTORY' was previously defined."
                  shift
                  DIRECTORY=${1:-"$DIRECTORY"}
                  ;;
  -v|--verbose)   VERBOSE=1 ;;
  -q|--quiet)     VERBOSE=0 ;; # Suppresses output and auto-kills existing servers
  -V|--version)   echo "$PRG $VERSION"; exit 0 ;;
  -h|--help)      usage 0 ;;
  -[pdvqVh]*) #shellcheck disable=SC2046 # expand aggregated short options
                  set -- '' $(printf -- "-%c " $(grep -o . <<<"${1:1}")) "${@:2}" ;;
  -*)             die 22 "Bad argument '$1'" ;;
  bg|fg|screen)   MODE=$1 ;;
  *)              [[ -n $DIRECTORY ]] && die 1 "Directory '$DIRECTORY' was previously defined."
                  DIRECTORY="$1"
                  ;;
esac; shift; done

[[ -z $DIRECTORY ]] && DIRECTORY='.'

# Verify directory exists
[[ -d "$DIRECTORY" ]] || die 2 "Directory '$DIRECTORY' does not exist"
DIRECTORY=$(readlink -en -- "$DIRECTORY") || die 2 "Failed to resolve directory path"

# Check dependencies after processing arguments (needed for mode variable)
check_dependencies

# Check if PORT is already in use
if nc -z localhost "$PORT" 2>/dev/null; then
  vecho "Port $PORT is already in use"
  # Find PHP processes using this port
  declare -a pids=()
  mapfile -t pids < <(lsof -i :"$PORT" -t 2>/dev/null | xargs -r ps -o pid= -o cmd= -p | grep "php -S localhost:$PORT" | awk '{print $1}')
  if [[ ${#pids[@]} -gt 0 ]]; then
    vecho "Found PHP server processes using port $PORT:"
    for pid in "${pids[@]}"; do
      vecho "  PID $pid: $(ps -p "$pid" -o cmd= 2>/dev/null || vecho 'Unknown process')"
    done
    ((VERBOSE)) && read -r -p "$PRG: Do you want to kill these processes? y/n " yn || yn=y
    [[ $yn == y ]] || exit 1
    for pid in "${pids[@]}"; do
      kill "$pid" 2>/dev/null && vecho "Killed process $pid" || vecho "Failed to kill process $pid"
    done
    # Wait a moment for processes to terminate
    sleep 1.5
    # Check if port is still in use
    nc -z localhost "$PORT" 2>/dev/null \
        && die 1 "Port $PORT is still in use. Please try a different port."
    vecho "Port $PORT is now available"
  else
    exit 1
  fi
fi

vecho "localhost:$PORT for $DIRECTORY"

# Function to start PHP server
start_php_server() {
  # Create router file if it doesn't exist
  local router_file="${DIRECTORY}/router.php"
  [[ -f "$router_file" ]] || vecho "No router file found. Using default PHP server routing."
  
  # Command to run
  local php_cmd=("php" "-S" "localhost:${PORT}" "-t" "${DIRECTORY}/")
  
  # Add router file if it exists
  [[ -f "$router_file" ]] && php_cmd+=("$router_file")
  
  case "$MODE" in
    bg)
      # Run in background
      vecho "Starting PHP server in background"
      "${php_cmd[@]}" > /dev/null 2>&1 &
      local server_pid=$!
      SERVER_PIDS+=("$server_pid")
      # Verify server started correctly
      sleep 1
      kill -0 "$server_pid" 2>/dev/null || die 1 "PHP server failed to start. Check for errors."
      vecho "Server started with PID $server_pid"
      vecho "To stop it, run: kill $server_pid"
      vecho "$PRG will now exit, but the PHP server will continue running in the background."
      exit 0
      ;;
    screen)
      # Create a detached screen session
      vecho "Starting PHP server in screen session named 'localhost-$PORT'"
      vecho "Use 'screen -r localhost-$PORT' to reattach to the server"
      vecho "Use Ctrl+A followed by D to detach from screen"
      # Create screen session
      screen -dmS "localhost-$PORT" "${php_cmd[@]}"
      # Verify screen session exists
      sleep 1
      screen -list | grep -q "localhost-$PORT" || die 1 "Failed to create screen session. Check for errors."
      vecho "$PRG will now exit, but the PHP server will continue running in screen."
      exit 0
      ;;
    *)
      # Default: run in foreground (script will not exit until server is stopped)
      vecho "Starting PHP server in foreground. Press Ctrl+C to stop."
      vecho "Server URL: http://localhost:$PORT/"
      # Execute PHP server in foreground
      "${php_cmd[@]}"
      ;;
  esac
}

# Start the PHP server
start_php_server

#fin
